from datetime import datetime, timedelta
import httpx
from fastapi import FastAPI
from pydantic import BaseModel
import logging
from fastapi.middleware.cors import CORSMiddleware
import re
import json

# Logging pra debugar e ver tudo que acontece rodando a API
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# URL da sua API C# (.NET) ‚Äî onde manda os alertas gerados por aqui
C_SHARP_ENDPOINT = "https://disasterlink-api.fly.dev/api/alertasclimaticos"

# Guarda o √∫ltimo alerta enviado por cidade, pra n√£o ficar mandando duplicado
last_alert_by_city: dict[str, dict] = {}

# Pra n√£o carregar os mesmos alertas duas vezes quando inicia o servi√ßo
existing_alerts_loaded = False

# Modelo dos dados que chegam do sensor
class Sensors(BaseModel):
    city: str
    temperature: float
    humidity: float
    windSpeed: float  # agora s√≥ usamos windSpeed, n√£o tem mais waterLevel

# Modelo do retorno da rota /anomaly
class AlertOut(BaseModel):
    sent: bool
    reason: str | None = None

app = FastAPI()

# Libera o CORS pra tudo ‚Äî pode acessar de qualquer lugar
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Fun√ß√£o que busca os alertas j√° existentes na sua API .NET pra n√£o duplicar
async def load_existing_alerts():
    global existing_alerts_loaded, last_alert_by_city

    if existing_alerts_loaded:
        return  # se j√° carregou uma vez, n√£o precisa de novo

    try:
        logger.info("üîÑ Carregando alertas existentes da API C#...")
        async with httpx.AsyncClient(timeout=10) as cli:
            resp = await cli.get(C_SHARP_ENDPOINT)
            resp.raise_for_status()
            alerts = resp.json()

            for alert in alerts:
                cidade = alert.get("cidade")
                if not cidade:
                    continue

                # Pega a data/hora no formato "dd/MM/yyyy HH:mm"
                data_hora = alert.get("dataHora", "")
                if data_hora:
                    match = re.match(r"(\d{2})/(\d{2})/(\d{4}) (\d{2}):(\d{2})", data_hora)
                    if match:
                        day, month, year, hour, minute = map(int, match.groups())
                        alert_time = datetime(year, month, day, hour, minute)

                        # S√≥ considera alertas das √∫ltimas 24h
                        if datetime.now() - alert_time < timedelta(hours=24):
                            last_alert_by_city[cidade] = {
                                "tipo": alert.get("tipoAlerta", ""),
                                "time": alert_time
                            }
                            logger.info(f"‚úÖ Registrado alerta existente para {cidade}: {alert.get('tipoAlerta')} em {alert_time}")

            logger.info(f"‚úÖ Carregados {len(last_alert_by_city)} alertas recentes da API C#")
    except Exception as e:
        logger.error(f"‚ùå Erro ao carregar alertas existentes: {str(e)}")
    finally:
        existing_alerts_loaded = True

# Fun√ß√£o pra checar se j√° tem alerta recente pra cidade antes de mandar outro
async def check_existing_alert(city: str) -> bool:
    try:
        day_ago = datetime.now() - timedelta(hours=24)

        async with httpx.AsyncClient(timeout=10) as cli:
            resp = await cli.get(C_SHARP_ENDPOINT)
            resp.raise_for_status()

            if resp.status_code != 200:
                logger.error(f"Erro ao consultar API: status code {resp.status_code}")
                return False

            try:
                alerts = resp.json()
            except json.JSONDecodeError:
                logger.error(f"Erro ao decodificar resposta JSON: {resp.text}")
                return False

            for alert in alerts:
                if alert.get("cidade", "").lower() != city.lower():
                    continue

                data_hora = alert.get("dataHora", "")
                if not data_hora:
                    continue

                match = re.match(r"(\d{2})/(\d{2})/(\d{4}) (\d{2}):(\d{2})", data_hora)
                if not match:
                    continue

                day, month, year, hour, minute = map(int, match.groups())
                alert_time = datetime(year, month, day, hour, minute)

                if datetime.now() - alert_time < timedelta(hours=24):
                    logger.info(f"‚úÖ Encontrado alerta existente para {city}: {alert.get('tipoAlerta')} em {data_hora}")
                    return True

            logger.info(f"‚úÖ Nenhum alerta recente encontrado para {city}")
            return False

    except Exception as e:
        logger.error(f"‚ùå Erro ao verificar alertas existentes: {str(e)}")
        # Se der erro, finge que n√£o tem alerta (melhor do que perder alerta importante)
        return False

# Fun√ß√£o que decide se deve ou n√£o mandar alerta, baseado nos dados dos sensores
def alert_type(t: float, h: float, w: float) -> list[str]:
    alertas = []

    # Temperatura (primeiro os extremos)
    if t <= 5:
        alertas.append("Muito Frio")
    elif t <= 14:
        alertas.append("Frio")

    if t >= 39:
        alertas.append("Calor Extremo")
    elif t >= 32:
        alertas.append("Muito Quente")

    # Vento (tamb√©m do mais forte pro menos forte)
    if w >= 22.2:
        alertas.append("Vento Perigoso")
    elif w >= 13.9:
        alertas.append("Vento Forte")

    # Umidade
    if h <= 20:
        alertas.append("Umidade Baixa")

    return alertas

# Endpoint principal da API ‚Äî recebe os dados do sensor e decide se gera alerta
@app.post("/anomaly", response_model=AlertOut)
async def detect_and_forward(s: Sensors):
    logger.info(f"üì• Recebido: {s.dict()}")
    alertas = alert_type(s.temperature, s.humidity, s.windSpeed)

    if not alertas:
        logger.info("‚ÑπÔ∏è Sem anomalia detectada.")
        return {"sent": False, "reason": "Sem anomalia"}

    # Formata valores pros templates das mensagens
    temp = round(s.temperature, 1)
    hum = round(s.humidity, 1)
    wind = round(s.windSpeed, 1)

    # Se tem mais de um alerta, junta tudo num s√≥ tipo
    if len(alertas) == 1:
        tipo = alertas[0]
    else:
        tipo = " + ".join(alertas)

    # Antes de mandar, verifica se j√° tem alerta pra essa cidade nas √∫ltimas 24h
    has_recent_alert = await check_existing_alert(s.city)
    if has_recent_alert:
        logger.info(f"‚ÑπÔ∏è Alerta ignorado: {s.city} j√° possui alerta nas √∫ltimas 24h")
        return {"sent": False, "reason": f"Alerta j√° enviado para {s.city} nas √∫ltimas 24h"}

    # Monta mensagem: se s√≥ um alerta, usa template simples; se v√°rios, usa combina√ß√£o
    if len(alertas) == 1:
        descricao = MESSAGE_TEMPLATES[alertas[0]].format(
            cidade=s.city,
            temperatura=temp,
            umidade=hum,
            vento=wind
        )
    else:
        descricao = generate_combined_message(alertas, s.city, temp, hum, wind)

    now = datetime.utcnow()  # Data/hora pra logs, mas API define a data final

    # Prepara o payload pro POST na API C#
    payload = {
        "cidade": s.city,
        "tipoAlerta": tipo,
        "temperatura": temp,
        "umidade": hum,
        "vento": wind,
        "descricao": descricao,
        # dataHora n√£o vai, a API gera
    }

    logger.debug(f"üîç Verificando condi√ß√µes para alerta:")
    logger.debug(f"   - Tipos detectados: {alertas}")
    logger.debug(f"   - Tipo combinado: {tipo}")
    logger.debug(f"   - Temperatura: {temp}¬∞C")
    logger.debug(f"   - Umidade: {hum}%")
    logger.debug(f"   - Vento: {wind} m/s")
    logger.debug(f"   - Descri√ß√£o gerada: {descricao}")
    logger.debug(f"   - Payload completo a ser enviado: {json.dumps(payload, ensure_ascii=False)}")

    logger.info(f"üì§ Enviando alerta para API C#: {payload}")

    try:
        async with httpx.AsyncClient(timeout=5) as cli:
            logger.debug(f"üîå Conectando ao endpoint: {C_SHARP_ENDPOINT}")
            logger.debug(f"üîç JSON exato enviado: {json.dumps(payload, ensure_ascii=False)}")
            resp = await cli.post(C_SHARP_ENDPOINT, json=payload)
            logger.debug(f"üìÑ Resposta: Status={resp.status_code}, Headers={resp.headers}, Corpo={resp.text}")

            resp.raise_for_status()
            logger.info(f"‚úÖ Alerta enviado com sucesso! Resposta: {resp.status_code}")
            logger.debug(f"üìÑ Resposta completa: {resp.text}")
            return {"sent": True, "reason": tipo}
    except Exception as e:
        logger.error(f"‚ùå Erro ao enviar alerta: {str(e)}")
        if hasattr(e, 'response') and e.response is not None:
            logger.error(f"üìÑ Detalhes do erro: Status={e.response.status_code}, Corpo={e.response.text}")
        return {"sent": False, "reason": f"Erro ao enviar: {str(e)}"}

# Fun√ß√£o pra criar mensagens combinadas pra quando tem mais de um alerta na cidade ao mesmo tempo
def generate_combined_message(alertas: list[str], cidade: str, temp: float, hum: float, wind: float) -> str:
    tipo_combinado = " + ".join(sorted(alertas))
    if tipo_combinado in COMBINED_TEMPLATES:
        return COMBINED_TEMPLATES[tipo_combinado].format(
            cidade=cidade,
            temperatura=temp,
            umidade=hum,
            vento=wind
        )

    # Se n√£o achar template pronto, monta mensagem na m√£o mesmo
    categorias = {
        "temperatura": [],
        "vento": [],
        "umidade": []
    }
    for alerta in alertas:
        if alerta in ["Muito Frio", "Frio", "Muito Quente", "Calor Extremo"]:
            categorias["temperatura"].append(alerta)
        elif alerta in ["Vento Forte", "Vento Perigoso"]:
            categorias["vento"].append(alerta)
        elif alerta == "Umidade Baixa":
            categorias["umidade"].append(alerta)

    partes = []
    icones = {
        "temperatura_frio": "‚ùÑÔ∏è",
        "temperatura_quente": "üî•",
        "vento": "üå™Ô∏è",
        "umidade": "üíß"
    }
    if categorias["temperatura"]:
        icone = icones["temperatura_frio"] if "Frio" in "".join(categorias["temperatura"]) else icones["temperatura_quente"]
        temp_alert = categorias["temperatura"][0]
        partes.append(f"{icone} {temp_alert} ({temp}¬∞C)")
    if categorias["vento"]:
        partes.append(f"{icones['vento']} {categorias['vento'][0]} ({wind} m/s)")
    if categorias["umidade"]:
        partes.append(f"{icones['umidade']} Umidade Baixa ({hum}%)")
    alerta_combinado = " + ".join(partes)
    return f"‚ö†Ô∏è ALERTA COMBINADO em {cidade}: {alerta_combinado}! Tome cuidados especiais para todas estas condi√ß√µes simultaneamente."

# Mensagens padr√£o pra cada tipo de alerta
MESSAGE_TEMPLATES = {
    "Frio":           "‚ùÑÔ∏è Aten√ß√£o, {cidade}! A temperatura est√° baixa ({temperatura}¬∞C). Proteja-se do frio e mantenha-se aquecido.",
    "Muito Frio":     "ü•∂ Alerta de frio intenso em {cidade} ({temperatura}¬∞C)! Risco de hipotermia. Busque abrigo e agasalhe-se bem.",
    "Muito Quente":   "‚òÄÔ∏è Calor intenso em {cidade} ({temperatura}¬∞C)! Beba bastante √°gua, evite o sol forte e procure locais frescos.",
    "Calor Extremo":  "üî• Perigo: calor extremo em {cidade} ({temperatura}¬∞C)! Risco elevado √† sa√∫de. Evite atividades externas e hidrate-se constantemente.",
    "Vento Forte":    "üå¨Ô∏è Ventos fortes atingindo {cidade} ({vento} m/s)! Cuidado com objetos soltos e estruturas inst√°veis.",
    "Vento Perigoso": "üå™Ô∏è Alerta de vento perigoso em {cidade} ({vento} m/s)! Danos podem ocorrer. Procure abrigo seguro imediatamente.",
    "Umidade Baixa":  "üíß Ar muito seco em {cidade} (umidade {umidade}%)! Mantenha-se hidratado e proteja as vias respirat√≥rias."
}

# Mensagens prontas pra combina√ß√µes de alertas (dois ou mais ao mesmo tempo)
COMBINED_TEMPLATES = {
    "Calor Extremo + Umidade Baixa": "üî•üíß ATEN√á√ÉO {cidade}! Condi√ß√µes extremamente perigosas: calor extremo ({temperatura}¬∞C) com umidade muito baixa ({umidade}%)! Risco cr√≠tico de desidrata√ß√£o e problemas de sa√∫de. Hidrate-se constantemente e evite exposi√ß√£o ao sol.",
    "Muito Quente + Umidade Baixa": "‚òÄÔ∏èüíß Alerta em {cidade}: calor intenso ({temperatura}¬∞C) combinado com ar muito seco ({umidade}%)! Beba muita √°gua e evite atividades ao ar livre.",
    "Vento Perigoso + Calor Extremo": "üå™Ô∏èüî• PERIGO em {cidade}! Combina√ß√£o de vento perigoso ({vento} m/s) e calor extremo ({temperatura}¬∞C)! Busque abrigo seguro e mantenha-se hidratado.",
    "Muito Frio + Vento Forte": "‚ùÑÔ∏èüå¨Ô∏è Condi√ß√µes severas em {cidade}: frio intenso ({temperatura}¬∞C) com ventos fortes ({vento} m/s)! Sensa√ß√£o t√©rmica muito baixa. Busque abrigo e agasalhe-se bem.",
    "Frio + Vento Forte": "‚ùÑÔ∏èüå¨Ô∏è Aten√ß√£o {cidade}: frio ({temperatura}¬∞C) com ventos fortes ({vento} m/s)! Sensa√ß√£o t√©rmica reduzida. Agasalhe-se bem ao sair.",
    "Vento Forte + Umidade Baixa": "üå¨Ô∏èüíß Alerta em {cidade}: ventos fortes ({vento} m/s) e umidade baixa ({umidade}%)! Risco aumentado de ressecamento e propaga√ß√£o de inc√™ndios.",
    "Muito Quente + Vento Forte": "‚òÄÔ∏èüå¨Ô∏è Condi√ß√µes adversas em {cidade}: calor intenso ({temperatura}¬∞C) com ventos fortes ({vento} m/s)! Evite exposi√ß√£o prolongada ao sol e hidrate-se.",

    # Combina√ß√µes de 3 alertas
    "Calor Extremo + Umidade Baixa + Vento Forte": "üî•üíßüå¨Ô∏è PERIGO EXTREMO em {cidade}! Tr√≠plice amea√ßa: calor extremo ({temperatura}¬∞C), umidade muito baixa ({umidade}%) e ventos fortes ({vento} m/s)! Risco grave de desidrata√ß√£o, inc√™ndios e problemas respirat√≥rios. Evite qualquer atividade externa, hidrate-se constantemente e busque locais protegidos.",
    "Muito Quente + Umidade Baixa + Vento Forte": "‚òÄÔ∏èüíßüå¨Ô∏è ALERTA CR√çTICO em {cidade}! Combina√ß√£o perigosa: calor intenso ({temperatura}¬∞C), baixa umidade ({umidade}%) e ventos fortes ({vento} m/s)! Risco elevado de desidrata√ß√£o e inc√™ndios. Mantenha-se hidratado e em locais protegidos.",
    "Calor Extremo + Vento Perigoso + Umidade Baixa": "üî•üå™Ô∏èüíß EMERG√äNCIA CLIM√ÅTICA em {cidade}! Condi√ß√µes extremamente perigosas: calor extremo ({temperatura}¬∞C), ventos perigosos ({vento} m/s) e umidade cr√≠tica ({umidade}%)! Risco m√°ximo √† sa√∫de e seguran√ßa. Busque abrigo seguro imediatamente e mantenha-se hidratado."
}

# Se rodar esse arquivo direto (python anomaly.py), sobe o servidor local pra teste
if __name__ == "__main__":
    import uvicorn
    print("üöÄ Iniciando servidor FastAPI na porta 8080...")
    uvicorn.run("app:app", host="127.0.0.1", port=8080, reload=False)
